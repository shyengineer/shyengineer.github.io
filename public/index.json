[{"content":"1. 자! \u0026lsquo;성능의 벽\u0026rsquo;에 부딪히셨나요? 지난 시간에 우리는 업데이트 루프를 통해 모든 입자를 순회하는 법을 배웠습니다!! 하지만 입자가 1,000개를 넘어 10,000개가 되면 어떻게 될까요?\n특히 입자끼리 충돌하거나 서로 영향을 주고받는 경우, 모든 입자를 서로 대조하면 계산량이 $O(n^2)$으로 폭증하게 됩니다!! 즉, 입자가 10배 늘어나면 계산은 100배나 힘들어지는 거죠!! 이 문제를 해결할 구원투수가 바로 **공간 분할(Spatial Partitioning)**입니다!!\n2. 공간 분할: \u0026ldquo;근처에 있는 애들만 신경 써!!\u0026rdquo; 공간 분할의 핵심 아이디어는 아주 단순합니다!! 광활한 물리 세계를 여러 개의 **\u0026lsquo;구역(Grid/Cell)\u0026rsquo;**으로 나누는 것이죠!!\n기존 방식: 모든 입자(A)가 세상의 모든 입자(B, C, D\u0026hellip;)와 부딪히는지 확인합니다!! (매우 비효율적!!) 공간 분할 방식: 입자(A)가 속한 칸과 그 주변 칸에 있는 친구들하고만 대조합니다!! 멀리 있는 입자들은 아예 무시하는 거죠!! 정말 똑똑하죠? 3. C++ Grid 기반 공간 분할 구현 예시!! 우리 관리자인 PhysicsWorld에 그리드 시스템을 도입해 봅시다!!\n#include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; // 공간을 나누는 칸(Cell)의 크기 const int CELL_SIZE = 50; class SpatialGrid { private: // 좌표를 키(Key)로 사용해 해당 구역의 입자들을 관리합니다!! std::map\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::vector\u0026lt;Particle*\u0026gt;\u0026gt; grid; public: // 입자의 위치에 따라 적절한 칸에 배치합니다!! void registerParticle(Particle* p) { int cellX = static_cast\u0026lt;int\u0026gt;(p-\u0026gt;getPosition().x / CELL_SIZE); int cellY = static_cast\u0026lt;int\u0026gt;(p-\u0026gt;getPosition().y / CELL_SIZE); grid[{cellX, cellY}].push_back(p); } void clear() { grid.clear(); } // 특정 구역 주변의 입자들만 가져오는 마법!! std::vector\u0026lt;Particle*\u0026gt; getNearby(Particle* p) { // ... 주변 9개 칸의 입자들만 모아서 반환하는 로직 ... } }; 4. 왜 공간 분할이 성능을 극한으로 끌어올릴까요? 불필요한 계산 제거: 수천 번의 연산이 단 몇 번의 연산으로 줄어듭니다!! 연산 복잡도가 거의 $O(n)$에 가까워지는 기적을 볼 수 있어요!!\n메모리 캐시 효율: 근처에 있는 데이터를 연속적으로 처리하므로 CPU가 아주 좋아합니다!!\n확장성: 이제 입자가 수만 개가 되어도 시뮬레이션이 멈추지 않고 매끄럽게 돌아갑니다!!\n5. 경제 시뮬레이션에서의 응용: 로컬 시장!! 이 기법은 경제학의 **\u0026lsquo;지역 시장 모델\u0026rsquo;**과 같습니다!! 전 세계의 모든 소비자와 기업이 실시간으로 상호작용하는 것은 불가능하죠.\n대신 **\u0026lsquo;물류 거점\u0026rsquo;**이나 **\u0026lsquo;지역 상권\u0026rsquo;**이라는 공간적 제약을 두어, 그 안의 경제 주체들끼리 우선 거래하게 설계하면 훨씬 현실적이고 빠른 시뮬레이션이 가능해집니다!!\n💡 성능의 마법사가 되어보신 소감이 어떠신가요? 공간 분할은 현대 게임 엔진과 대규모 시뮬레이션의 필수 기술입니다!! 여러분의 엔진에 이 기법을 적용하는 순간, 상상만 하던 거대한 세계를 직접 움직일 수 있게 될 거예요!!\n혹시 그리드 방식보다 더 정교한 **쿼드트리(Quad-tree)**나 **옥트리(Oc-tree)**가 궁금하신가요?\n여러분의 다음 도전 과제를 댓글로 알려주세요!! 제가 끝까지 함께하겠습니다!!\n","permalink":"https://shyengineer.github.io/posts/7th-post/","summary":"입자가 늘어날수록 급격히 느려지는 시뮬레이션! 모든 객체를 일일이 대조하지 않고, 필요한 영역만 효율적으로 탐색하는 공간 분할 기법의 마법을 공개합니다!!","title":"C++ 성능의 한계를 돌파하라: 공간 분할(Spatial Partitioning)로 수만 개의 입자 다루기!!"},{"content":"1. 업데이트 루프(Update Loop): 시뮬레이션의 심장박동!! 물리 시뮬레이션은 멈춰있는 사진이 아니라 흐르는 영화와 같습니다!! 관리자는 매 찰나(Frame)마다 모든 객체에게 \u0026ldquo;자, 다음 위치로 이동해!\u0026ldquo;라고 명령을 내려야 하죠. 이 반복되는 과정을 업데이트 루프라고 부릅니다!!\n보통 아래와 같은 순서로 진행돼요:\n입력 처리: 사용자나 시스템의 명령을 듣습니다. 물리 업데이트: 모든 객체의 가속도, 속도, 위치를 계산합니다. 렌더링: 계산된 결과를 화면에 그립니다. 2. 수많은 객체를 담는 그릇: std::vector!! 관리자가 객체들을 효율적으로 돌보려면 한 곳에 잘 모아두어야 합니다. C++에서 가장 사랑받는 그릇은 바로 std::vector입니다!!\n왜 std::vector일까요?\n메모리 밀집도: 데이터가 메모리상에 나란히 붙어 있어, CPU가 다음 객체를 찾을 때 속도가 빛처럼 빠릅니다!! 유연함: 새로운 입자가 태어나거나(Factory 이용), 수명이 다해 사라질 때 관리가 매우 용이합니다!! 3. 효율적인 관리자 코드 구현!! 지난번에 만든 싱글톤 PhysicsWorld에 객체 관리 기능을 추가해 봅시다!!\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; class PhysicsWorld { private: // 관리할 입자들을 담는 벡터 (다형성 활용!!) std::vector\u0026lt;std::unique_ptr\u0026lt;Particle\u0026gt;\u0026gt; particles; PhysicsWorld() {} PhysicsWorld(const PhysicsWorld\u0026amp;) = delete; PhysicsWorld\u0026amp; operator=(const PhysicsWorld\u0026amp;) = delete; public: static PhysicsWorld\u0026amp; getInstance() { static PhysicsWorld instance; return instance; } // 입자 추가 (팩토리에서 만든 객체를 전달받음!!) void addParticle(std::unique_ptr\u0026lt;Particle\u0026gt; p) { particles.push_back(std::move(p)); } // 핵심 업데이트 루프!! void update(double deltaTime) { // 모든 입자를 순회하며 물리 법칙 적용!! for (auto\u0026amp; p : particles) { p-\u0026gt;update(deltaTime); } std::cout \u0026lt;\u0026lt; particles.size() \u0026lt;\u0026lt; \u0026#34;개의 입자가 움직이고 있습니다!!\\n\u0026#34;; } }; 4. 최적화 꿀팁: 데이터 관리의 핵심!! 객체가 많아질수록 성능이 중요해집니다!! 관리자로서 다음 두 가지를 꼭 기억하세요!!\n불필요한 객체 삭제: 화면 밖으로 나가거나 수명이 다한 입자는 바로바로 벡터에서 제거해야 합니다. 그렇지 않으면 \u0026lsquo;유령 객체\u0026rsquo;들이 CPU를 계속 괴롭힐 거예요!!\nReserve 활용: 벡터의 크기가 커질 때 메모리를 새로 할당하는 비용은 꽤 큽니다. 대략적인 개수를 안다면 particles.reserve(1000);으로 미리 공간을 확보하세요!!\n5. 경제 모델로의 응용: 시장의 순환!! 이 루프는 경제 시뮬레이션에서 **\u0026lsquo;회계 연도\u0026rsquo;**나 **\u0026lsquo;거래 주기\u0026rsquo;**가 됩니다!! 싱글톤인 Market 관리자가 모든 Agent(가계, 기업)를 순회하며 수입과 지출을 계산하고, 파산한 주체는 리스트에서 제거하며 시스템을 유지하는 것과 똑같은 원리랍니다!!\n💡 관리자의 업무를 자동화한 소감이 어떠신가요? 이제 여러분의 물리 세계는 스스로 숨 쉬며 움직일 준비가 끝났습니다!! 수천 개의 입자가 동시에 춤추는 모습, 상상만 해도 짜릿하지 않나요?\n혹시 \u0026ldquo;수만 개가 넘어가니 너무 느려져요!\u0026rdquo; 하시는 분 계신가요? 다음 시간에는 성능을 극한으로 끌어올리는 공간 분할(Spatial Partitioning) 기법에 대해 알아볼까요?\n언제든 여러분의 생각을 댓글로 들려주세요!! 함께 멋진 엔진을 완성해 봅시다!!\n","permalink":"https://shyengineer.github.io/posts/6th-post/","summary":"싱글톤 관리자가 수많은 객체를 한 번에 처리하는 메커니즘을 배웁니다! 데이터의 연속성을 활용한 성능 최적화와 안정적인 루프 설계법을 공개합니다!!","title":"C++ 물리 엔진의 심장: 효율적인 업데이트 루프와 벡터(std::vector) 관리 기술!!"},{"content":"1. 자! 싱글톤 패턴(Singleton Pattern)이란 무엇일까요? 우리가 지난 시간에 팩토리 패턴으로 수많은 입자들을 찍어내는 공장을 만들었죠! 그런데 이 입자들이 뛰어놀 **\u0026lsquo;세계(World)\u0026rsquo;**나 전체 시뮬레이션을 제어하는 **\u0026lsquo;물리 엔진\u0026rsquo;**이 여러 개라면 어떻게 될까요? 중력이 이중으로 적용되거나 데이터가 꼬이는 대혼란이 발생할 거예요!!\n이처럼 \u0026ldquo;시스템 전체에서 객체가 딱 하나만 존재해야 할 때\u0026rdquo; 사용하는 마법 같은 설계 기법이 바로 싱글톤 패턴입니다!! 정말 든든한 관리자죠?\n2. 싱글톤의 3가지 철칙!! 싱글톤을 설계할 때는 아래 세 가지만 기억하면 됩니다!!\n생성자를 숨겨라 (Private Constructor): 외부에서 new를 이용해 마음대로 객체를 만들지 못하게 문을 잠급니다!! 복사를 금지하라 (Delete Copy): 객체가 복제되어 두 개가 되는 것을 원천 차단합니다!! 유일한 통로를 열어라 (Static Instance): 어디서든 접근할 수 있는 단 하나의 \u0026lsquo;열쇠\u0026rsquo; 함수를 제공합니다!! 3. C++ 싱글톤 구현 코드!! (Modern C++ 방식) C++11 이후 가장 권장되는 \u0026lsquo;Meyers\u0026rsquo; Singleton\u0026rsquo; 방식으로 구현해 봅시다!! 이 방식은 메모리 관리도 쉽고 스레드 안전(Thread-safe)하답니다!!\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 물리 세계를 총괄하는 PhysicsWorld 클래스 class PhysicsWorld { private: // [규칙 1] 생성자를 private으로! 외부 생성 금지!! PhysicsWorld() { std::cout \u0026lt;\u0026lt; \u0026#34;태초의 물리 세계가 생성되었습니다!!\u0026#34; \u0026lt;\u0026lt; std::endl; } // [규칙 2] 복사 생성자와 대입 연산자 제거!! PhysicsWorld(const PhysicsWorld\u0026amp;) = delete; PhysicsWorld\u0026amp; operator=(const PhysicsWorld\u0026amp;) = delete; public: // [규칙 3] 유일한 인스턴스에 접근하는 정적 메서드 static PhysicsWorld\u0026amp; getInstance() { static PhysicsWorld instance; // 프로그램 실행 중 단 한 번만 생성됨!! return instance; } void updateWorld() { std::cout \u0026lt;\u0026lt; \u0026#34;모든 물리 객체의 상태를 업데이트합니다!!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // PhysicsWorld myWorld; // 에러! 직접 만들 수 없어요!! // 언제 어디서든 getInstance()로 관리자를 소환!! PhysicsWorld\u0026amp; world = PhysicsWorld::getInstance(); world.updateWorld(); // 다른 곳에서 또 불러도 결국 \u0026#39;같은\u0026#39; 객체입니다!! PhysicsWorld::getInstance().updateWorld(); return 0; } 4. 왜 싱글톤을 써야 할까요? (장점) 자원 절약: 무거운 관리 객체를 여러 번 만들 필요가 없어 메모리를 아낄 수 있습니다!!\n데이터 일관성: 모든 입자가 동일한 PhysicsWorld 안에서 규칙을 따르므로 데이터가 안전합니다!!\n전역 접근성: 포인터를 복잡하게 넘겨주지 않아도 getInstance()만 알면 어디서든 관리자에게 명령할 수 있어요!!\n5. 경제 시뮬레이션에서의 응용: 중앙은행(Central Bank) 입자 시뮬레이션에 PhysicsWorld가 있다면, 경제 모델에는 **\u0026lsquo;CentralBank\u0026rsquo;**가 있습니다!!\nBase Class: EconomicAgent (가계, 기업)\nSingleton Class: CentralBank (기준 금리 결정, 통화량 조절)\n모든 경제 주체가 각자 다른 금리를 적용받으면 안 되겠죠? 싱글톤으로 설계된 중앙은행이 시스템 전체의 기준을 잡아주는 역할을 수행하게 됩니다!!\n💡 오늘의 요약!! Singleton: 단 하나의 인스턴스만 보장하는 패턴!!\nStatic: 객체 없이도 호출 가능하며 프로그램 수명 동안 유지됩니다!!\nSafety: 전역 변수처럼 쓰이지만 캡슐화를 유지할 수 있어 훨씬 안전합니다!!\n다음 시간에는 이 유일한 관리자가 수많은 객체를 효율적으로 순회하고 처리하는 업데이트 루프(Update Loop)와 데이터 관리에 대해 알아볼까요?\n궁금한 점은 언제든 댓글로 남겨주세요!! 우리 함께 마스터해 봐요!!\n","permalink":"https://shyengineer.github.io/posts/5th-post/","summary":"프로그램 전체에서 단 하나만 존재해야 하는 관리 객체, 싱글톤 패턴을 배워봅니다! 물리 세계(World)나 중앙 엔진을 안전하고 효율적으로 관리하는 비법을 공개합니다!!","title":"C++ 싱글톤 패턴(Singleton): 시스템을 총괄하는 유일한 관리자 설계하기!!"},{"content":"1. 자! 팩토리 패턴이 왜 필요한가요? 우리가 시뮬레이션을 만들다 보면 GravityParticle, SmokeParticle 등 수많은 객체가 필요해집니다!! 그런데 메인 코드 여기저기서 new GravityParticle(...)을 남발하면 어떻게 될까요?\n나중에 생성 로직이 바뀌면 모든 코드를 다 수정해야 하는 **\u0026lsquo;코드 지옥\u0026rsquo;**에 빠지게 됩니다!! 이때 **\u0026ldquo;객체 생성만 전문적으로 담당하는 공장\u0026rdquo;**을 하나 두면 모든 고민이 해결되지요!! 쉽죠?\n2. 팩토리 패턴의 구조 팩토리 패턴은 부모 클래스 타입의 포인터를 반환하는 \u0026lsquo;공장 함수\u0026rsquo;를 만드는 것이 핵심입니다!!\n3. C++ 팩토리 패턴 구현 코드!! 자! 코드를 직접 보면서 이해해 봅시다!! 어제 배운 virtual과 override가 어디에 쓰이는지 눈을 크게 뜨고 찾아보세요!!\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; // 1. 제품들의 부모 클래스 (추상적인 개념) class Particle { public: virtual ~Particle() {} virtual void showType() = 0; // 순수 가상 함수!! }; // 2. 구체적인 제품들 class GravityParticle : public Particle { public: void showType() override { std::cout \u0026lt;\u0026lt; \u0026#34;중력 입자 생성 완료!!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class WindParticle : public Particle { public: void showType() override { std::cout \u0026lt;\u0026lt; \u0026#34;바람 입자 생성 완료!!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 3. 마법의 공장 클래스!! class ParticleFactory { public: // 어떤 입자를 만들지 결정하는 공장 메서드 static std::unique_ptr\u0026lt;Particle\u0026gt; createParticle(const std::string\u0026amp; type) { if (type == \u0026#34;gravity\u0026#34;) { return std::make_unique\u0026lt;GravityParticle\u0026gt;(); } else if (type == \u0026#34;wind\u0026#34;) { return std::make_unique\u0026lt;WindParticle\u0026gt;(); } return nullptr; } }; int main() { // 공장에게 주문만 하면 끝!! 직접 new를 쓸 필요가 없어요!! auto p1 = ParticleFactory::createParticle(\u0026#34;gravity\u0026#34;); auto p2 = ParticleFactory::createParticle(\u0026#34;wind\u0026#34;); if (p1) p1-\u0026gt;showType(); if (p2) p2-\u0026gt;showType(); return 0; } 4. 팩토리 패턴의 엄청난 장점!! 결합도 감소!!: 메인 코드는 구체적인 자식 클래스 이름을 몰라도 됩니다!! 그냥 공장에 \u0026ldquo;이거 줘!\u0026ldquo;라고 말만 하면 되니까요!!\n유지보수 짱!!: 새로운 입자(예: MagicParticle)가 추가되어도, 공장 코드만 살짝 수정하면 끝납니다!! 다른 곳은 건드릴 필요가 없죠!!\n조건부 생성: 물리 환경 설정에 따라 \u0026ldquo;A 상황엔 1번 객체, B 상황엔 2번 객체\u0026quot;를 공장 안에서 똑똑하게 판단해서 만들어줄 수 있습니다!!\n5. 경제 시뮬레이션에서의 응용!! 경제 시뮬레이션에서도 이 패턴은 빛을 발합니다!!\nAgentFactory를 만들어서, 시장 상황에 따라 \u0026lsquo;공격적인 투자자\u0026rsquo;나 \u0026lsquo;보수적인 저축가\u0026rsquo;를 자동으로 생성하여 시장에 투입할 수 있지요!! 정말 멋지지 않나요?\n💡 공장장이 되어보신 소감이 어떠신가요? 팩토리 패턴을 적용하면 여러분의 코드가 한결 전문적으로 변한답니다!! 이해가 안 가는 부분이 있다면 언제든 질문해 주세요!! 다음 시간에는 이 객체들을 한 번에 관리하는 **싱글톤 패턴(Singleton)**에 대해 알아볼까요?\n","permalink":"https://shyengineer.github.io/posts/4th-post/","summary":"수많은 물리 객체를 일일이 직접 만들고 계신가요? 이제 팩토리 패턴을 통해 객체 생성 로직을 깔끔하게 분리하고 관리를 자동화해 봅시다!!","title":"C++ 팩토리 패턴(Factory Pattern): 객체 생성을 담당하는 스마트한 공장 세우기!!"},{"content":"1. 자! \u0026lsquo;가상 함수(virtual)\u0026lsquo;가 왜 필요할까요? 지난 시간에는 상속을 배웠지요? 하지만 단순히 물려받는 것만으로는 부족합니다!! 부모님이 \u0026ldquo;공부해라!\u0026ldquo;라고 말씀하셔도, 자식마다 \u0026ldquo;수학 공부\u0026rdquo;, \u0026ldquo;음악 공부\u0026rdquo; 등 구체적으로 하는 일은 다를 수 있잖아요!!\n이처럼 부모 클래스에서 이름을 정해주고, 실제 행동은 자식 클래스에서 결정하고 싶을 때 사용하는 것이 바로 virtual 키워드입니다!!\n2. virtual: \u0026ldquo;나중에 자식이 정할 거야!!\u0026rdquo; 부모 클래스의 메서드 앞에 virtual을 붙이면, C++ 시스템은 \u0026ldquo;아, 이 함수는 나중에 자식이 바꿀 수도 있겠구나!\u0026ldquo;라고 기억해 둡니다!!\nclass Parent { public: virtual void study() { std::cout \u0026lt;\u0026lt; \u0026#34;기본 공부를 합니다!!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 이렇게 virtual을 붙여줘야만, 나중에 우리가 다형성을 사용할 때 자식의 함수가 올바르게 호출된답니다!! 정말 중요하겠죠?\n3. override: \u0026ldquo;제가 확실히 물려받아 고쳤어요!!\u0026rdquo; 자! 자식 클래스에서 부모의 함수를 새로 만들 때는 override라는 꼬리표를 붙여주는 것이 매너입니다!!\nclass Child : public Parent { public: void study() override { // 부모의 study를 재정의했다는 표시!! std::cout \u0026lt;\u0026lt; \u0026#34;물리 공부를 열정적으로 합니다!!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 왜 override를 써야 할까요? 실수 방지!!: 부모 함수의 이름을 살짝 틀리게 적으면, 시스템이 \u0026ldquo;어? 부모한테 그런 함수 없는데?\u0026ldquo;라고 바로 알려줍니다!!\n가독성 짱!!: 코드를 읽는 다른 사람이 \u0026ldquo;아, 이건 부모 함수를 바꾼 거구나!\u0026ldquo;라고 바로 알 수 있죠!! 쉽죠?\n4. 왜 팩토리 패턴 전에 이걸 배워야 할까요? 자! 우리가 나중에 배울 팩토리 패턴은 \u0026ldquo;어떤 자식 객체를 만들지\u0026quot;를 결정하는 공장입니다!!\n이 공장에서 물건을 찍어낸 뒤에, 부모 타입의 포인터로 자식 객체들을 자유자재로 다루려면 오늘 배운 virtual과 override가 필수랍니다!! 이 개념이 흔들리면 공장이 제대로 돌아가지 않겠죠?\n5. 요약하자면 이렇습니다!! virtual: 부모가 자식에게 \u0026ldquo;너만의 스타일로 바꿔도 돼!!\u0026ldquo;라고 허락해 주는 키워드!!\noverride: 자식이 부모에게 \u0026ldquo;제가 멋지게 바꿨습니다!!\u0026ldquo;라고 보고하는 꼬리표!!\n💡 궁금한 점은 언제든 물어봐 주세요!! 가상 함수가 조금 어렵게 느껴지시나요? 아니면 코드가 잘 안 돌아가나요? 댓글로 남겨주시면 제가 친절히 답변해 드릴게요!! 우리 함께 마스터해 봐요!!\n","permalink":"https://shyengineer.github.io/posts/3rd-post/","summary":"상속을 제대로 활용하기 위해 반드시 알아야 할 virtual과 override! 부모 클래스의 기능을 자식이 어떻게 멋지게 재정의하는지 친절하게 설명해 드릴게요!!","title":"C++의 마법, virtual과 override 이해하기: 부모의 유산을 지혜롭게 물려받는 방법!!"},{"content":"1. 상속(Inheritance): 물리 엔진의 확장성 확보 자! 지난 포스팅에서 만든 Particle 클래스는 기초 물리 법칙만 수행했지요? 하지만 실제 환경에는 서로 다른 특징을 가진 객체들이 있습니다! 예를 들어 불꽃(Spark), 연기(Smoke), 단단한 공(Ball) 등이 있죠!!\n이때 각 객체마다 코드를 새로 만들지 말고!!! 공통 기능(위치, 속도 계산)은 부모 클래스에 두고 고유한 특징은 자식 클래스에서 정의하는 것이 상속의 핵심입니다!!\n2. 클래스 계층 구조 설계 상속을 이용하면 아래와 같은 계층 구조를 가질 수 있습니다.\n3. C++ 상속 구현 코드 부모 클래스의 update 메서드를 가상 함수(virtual)로 선언 그리고 자식 클래스에서 각 물리 법칙에 맞게 재정의(Override)하는 것이 포인트입니다!! 쉽죠?\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 기본 Particle 클래스 (부모) class Particle { protected: // 자식 클래스에서 접근 가능하도록 protected 설정 Vector2D position; Vector2D velocity; double mass; public: Particle(Vector2D pos, double m) : position(pos), velocity({0,0}), mass(m) {} // 가상 소멸자 필수 virtual ~Particle() {} // 가상 함수: 자식에서 다르게 구현할 수 있음 virtual void update(double deltaTime) { // 기본 가속도 법칙 (기본값은 등속도 운동) position += velocity * deltaTime; } void setVelocity(Vector2D v) { velocity = v; } }; // 상속 1: 중력의 영향을 받는 입자 class GravityParticle : public Particle { private: const double G = -9.8; public: GravityParticle(Vector2D pos, double m) : Particle(pos, m) {} // 오버라이딩: 중력 가속도 적용 void update(double deltaTime) override { velocity.y += G * deltaTime; Particle::update(deltaTime); // 부모의 위치 업데이트 로직 호출 } }; // 상속 2: 공기 저항을 받는 입자 (감쇠 적용) class SmokeParticle : public Particle { private: double drag; // 저항 계수 public: SmokeParticle(Vector2D pos, double m, double d) : Particle(pos, m), drag(d) {} void update(double deltaTime) override { velocity = velocity * drag; // 매 프레임 속도 감소 Particle::update(deltaTime); } }; 4. 다형성(Polymorphism)의 활용 상속의 진짜 마법은 다형성에서 나타납니다. 부모 타입의 포인터 배열 하나로 서로 다른 성질의 입자들을 한꺼번에 관리할 수 있습니다.\nint main() { std::vector\u0026lt;Particle*\u0026gt; world; world.push_back(new GravityParticle({0, 100}, 1.0)); world.push_back(new SmokeParticle({0, 0}, 0.5, 0.95)); for (int i = 0; i \u0026lt; 100; ++i) { for (auto p : world) { p-\u0026gt;update(0.1); // 각 객체의 실제 타입에 맞는 update가 호출됨! } } // 메모리 해제 for (auto p : world) delete p; return 0; } 5. 경제 모델로의 응용: 다양한 경제 주체 이 설계 방식은 경제 시뮬레이션에서도 똑같이 적용됩니다.\nBase Class: EconomicAgent (자산, 소비 로직)\nDerived Class 1: Consumer (소비 성향이 높은 주체)\nDerived Class 2: Investor (자산 증식 로직이 강화된 주체)\n이처럼 상속을 이용하면 복잡한 시스템을 매우 단순하고 명쾌하게 설계할 수 있습니다.\n💡 오늘의 OOP 핵심 요약 Protected: 자식 클래스에게만 데이터 접근을 허용합니다.\nVirtual Function: 실행 시점(Runtime)에 어떤 메서드를 실행할지 결정하는 다형성의 기초입니다.\nOverride: 부모의 기능을 내 입맛에 맞게 수정합니다.\n다음 시간에는 객체 생성의 복잡함을 해결해주는 **팩토리 패턴(Factory Pattern)**에 대해 알아보겠습니다!\n","permalink":"https://shyengineer.github.io/posts/2nd-post/","summary":"기본 Particle 클래스를 상속받아 중력, 공기 저항, 반발력 등 서로 다른 물리적 성질을 가진 객체들을 효율적으로 설계하는 방법을 알아봅니다.","title":"C++ 상속(Inheritance)으로 확장하는 물리 엔진: 다양한 물리 객체 구현하기"},{"content":"1. 왜 물리 엔진에 객체지향(OOP)이 필요한가? 물리 시뮬레이션을 구현할 때 단순히 변수와 함수의 나열로 작성하면, 입자가 수천 개로 늘어나는 순간 코드는 관리 불능 상태가 됩니다. **객체지향 프로그래밍(OOP)**은 각 물리적 실체를 하나의 \u0026lsquo;객체\u0026rsquo;로 정의하여 데이터와 로직을 묶어줍니다.\n특히 **캡슐화(Encapsulation)**를 통해 가속도, 속도, 위치와 같은 내부 상태를 보호하고, 정해진 메서드(update)를 통해서만 상태를 변화시키는 것이 중요합니다.\n2. 물리 법칙의 코드화: 뉴턴의 제2법칙 시뮬레이션의 핵심은 뉴턴의 운동 법칙입니다.\n$$\\vec{F} = m\\vec{a} \\implies \\vec{a} = \\frac{\\vec{F}}{m}$$\n이 물리 공식은 코드 상에서 매 프레임마다 가속도를 계산하고, 이를 통해 속도와 위치를 갱신하는 방식으로 구현됩니다.\n3. C++ 클래스 설계 (Source Code) 먼저 위치와 속도 계산을 편리하게 하기 위해 Vector2D 구조체를 정의하고, 이를 사용하는 Particle 클래스를 설계합니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 2D 벡터 구조체: 연산자 오버로딩을 통한 직관적 계산 struct Vector2D { double x, y; Vector2D operator+(const Vector2D\u0026amp; v) const { return {x + v.x, y + v.y}; } Vector2D operator*(double scalar) const { return {x * scalar, y * scalar}; } void operator+=(const Vector2D\u0026amp; v) { x += v.x; y += v.y; } }; // Particle 클래스: 캡슐화 적용 class Particle { private: Vector2D position; Vector2D velocity; Vector2D acceleration; double mass; public: Particle(Vector2D pos, double m) : position(pos), velocity({0, 0}), acceleration({0, 0}), mass(m) {} // 힘을 가하는 메서드 (F = ma) void applyForce(Vector2D force) { Vector2D a = force * (1.0 / mass); acceleration += a; } // 상태 업데이트 (오일러 적분법) void update(double deltaTime) { velocity += acceleration * deltaTime; position += velocity * deltaTime; // 가속도 초기화 (매 프레임 힘의 합력을 새로 계산하기 위함) acceleration = {0, 0}; } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Pos: (\u0026#34; \u0026lt;\u0026lt; position.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; position.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 질량 1.0인 입자를 (0,0)에 생성 Particle p({0.0, 0.0}, 1.0); // 중력(가속도 개념의 힘) 적용 예시 Vector2D gravity = {0.0, -9.8}; std::cout \u0026lt;\u0026lt; \u0026#34;--- Simulation Start ---\u0026#34; \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; 5; ++i) { p.applyForce(gravity); p.update(0.1); // 0.1초 단위 업데이트 p.display(); } return 0; } ┌────────────────────────┐ │ Vector2D │ ├────────────────────────┤ │ + x : double │ │ + y : double │ ├────────────────────────┤ │ + operator+(v) : Vector2D │ │ + operator*(scalar) : Vector2D │ │ + operator+=(v) : void │ └────────────────────────┘ ┌────────────────────────┐ │ Particle │ ├────────────────────────┤ │ - position : Vector2D │ │ - velocity : Vector2D │ │ - acceleration : Vector2D │ │ - mass : double │ ├────────────────────────┤ │ + Particle(pos, m) │ │ + applyForce(force) : void │ │ + update(deltaTime) : void │ │ + display() : void │ └────────────────────────┘ ▲ │ (has-a) │ Vector2D 4. 객체지향 설계의 핵심 포인트 캡슐화: position과 velocity를 private으로 두어 외부에서 직접 수정하는 것을 막았습니다. 오직 applyForce와 update를 통해서만 물리적 법칙에 따라 이동합니다.\n단일 책임 원칙 (SRP): Particle 클래스는 자신의 물리 상태를 갱신하는 역할만 수행합니다. 렌더링이나 세계(World) 관리는 별도의 클래스에 맡기는 것이 좋습니다.\n5. 마치며: 경제 모델로의 확장 이러한 **에이전트 기반 모델링(ABM)**은 경제학에서도 유용합니다. \u0026lsquo;입자\u0026rsquo;를 \u0026lsquo;가계\u0026rsquo;나 \u0026lsquo;기업\u0026rsquo;으로 바꾸고, \u0026lsquo;힘\u0026rsquo;을 \u0026lsquo;시장 이자율\u0026rsquo;이나 \u0026lsquo;소비 심리\u0026rsquo;로 치환하면 복잡한 경제 시스템을 시뮬레이션할 수 있는 기초가 됩니다.\n다음 포스팅에서는 이 구조를 바탕으로 **상속(Inheritance)**을 이용해 다양한 물리적 성질을 가진 객체들을 만들어 보겠습니다.\n💡 궁금한 점이 있으신가요? C++ 설계 패턴이나 물리 시뮬레이션 구현 중 어려운 부분이 있다면 댓글로 남겨주세요!\n","permalink":"https://shyengineer.github.io/posts/1st-post/","summary":"C++의 객체지향 원칙을 활용하여 물리 엔진의 기초가 되는 입자 시스템을 설계해 봅니다. 캡슐화와 연산자 오버로딩을 통해 유지보수가 용이한 코드를 작성하는 방법을 다룹니다.","title":"C++ OOP로 구현하는 물리 시뮬레이션: 객체지향으로 설계하는 입자(Particle) 엔진"},{"content":"1. 물리 수식 테스트 슈뢰딩거 방정식입니다: $$i\\hbar \\frac{\\partial}{\\partial t}\\Psi(\\mathbf{r},t) = \\hat{H}\\Psi(\\mathbf{r},t)$$\n2. 댓글 테스트 아래에 댓글창이 보인다면 성공입니다!\n","permalink":"https://shyengineer.github.io/posts/0-hello/","summary":"\u003ch3 id=\"1-물리-수식-테스트\"\u003e1. 물리 수식 테스트\u003c/h3\u003e\n\u003cp\u003e슈뢰딩거 방정식입니다:\n$$i\\hbar \\frac{\\partial}{\\partial t}\\Psi(\\mathbf{r},t) = \\hat{H}\\Psi(\\mathbf{r},t)$$\u003c/p\u003e\n\u003ch3 id=\"2-댓글-테스트\"\u003e2. 댓글 테스트\u003c/h3\u003e\n\u003cp\u003e아래에 댓글창이 보인다면 성공입니다!\u003c/p\u003e","title":"수식과 댓글 테스트"}]